---
layout: post
title: "Microservices, Microcosm"
date: 2017-10-22
excerpt: "The one about nature"
---
I had the great fortune several years ago to be introduced to a software architecture that consisted of many small pieces, all doing one job, adding up to something great. I didn't know it at the time, but my first experience in real-world software architecture had been in microservices, and, quite frankly, I haven't looked back.

The first real program I wrote was a chess game with a couple of friends for a end of the year school project. It was in state of the art Java 7 \(Timsort!\), organized by tried-and-true model-view-controller. But it had a deadline, and we all knew the world didn't need another chess game, so there were little compromises here and there \(hacks, there were hacks everywhere\). A few months passed and two of us tried our hand at a MIDI Show Control program in Java, again with MVC. We made a promise, this time, no compromises. And we didn't! We had factories everywhere, but the model was the model, the view was the view, and the controller was a total mess, which is probably why the program never lived up to our lofty expectations. It worked, but it wasn't exactly a UI/UX masterpiece.

When we put the final commit into our MIDI program, I honestly thought I was leaving computer science behind. I wanted to study politics, to try my hand at architecting Big Things\(tm\). I was dead wrong. Computer Science crept back into my life first in political science courses, then slammed on the accelerator when I was granted the opportunity to join Bratton Technology \(now [BlueLine Grid]()\). I learned some continuous deployment/continuous integration tooling around our iOS app, and was then asked to explore a JVM-based language called Scala, and write a little service using Typesafe's \(now Lightbend\) Akka library. For those that had the experience of using Spray and Akka, I could end right here, and you'd still get the point. For everyone else, the point is this: Six weeks into my first real engineering job, I wrote asynchronous, non-blocking, fault-tolerant code, that, should the need have arisen, could be distributed across multiple nodes. It was beautiful. It is still the most beautiful code I've ever written.

In the past few years, many people have had that same experience, and adopted services just like that for just about everything. Now, containerization has made things \(more\) portable, and clustering and orchestration have followed in earnest. But distributed systems means distributed problems, and storage, networking, logging, monitoring, security and all the rest have to catch up. There could be a 20 page news article about all the stuff that's coming next - service meshes, the Container Storage Interface - but that's not what I've been rambling on about.

I don't want to rehash the monolith versus microservices argument, I want to propose something a little bit more radical: microservices exist because they are natural. We don't live in a monolithic world. Everything that happens is the result of some long chain - the world is a graph. Facebook, Twitter and friends figured that out nearly a decade ago \(whether or not they figured out on purpose, however, I don't have an answer to\). You need not have a degree in math to understand graph theory - it's just nodes and edges. You can model our world with people as the nodes, places and events as the edges that connect them, or you can mix it up, connect events using people; however you decide to look at it, we live in a graph-based world. We built technology that enabled us to analyze it, and now, we model our architectures after it.

So, take a minute to look around you, organize the world in a graph. I think you'll find the all the analogues of the microservice movement out there in the real world - storage providers, service meshes, loggers, monitors, security systems - they're all distributed, and, as a result, have distributed problems. Over the next several weeks, I hope to explore this more deeply. Stay tuned.
